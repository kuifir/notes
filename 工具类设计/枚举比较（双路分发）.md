### 枚举比较的工具类，双路分发比较的使用（比如石头剪刀布）
- 首先，Competitor(竞争者)接口定义了一个和另一个Competitor竞争的类型,返回的结果是枚举类型。

    - 返回结果类型：
      ```java
            public enum Outcome { WIN,LOSE,DRAW }
      ```
    - Competitor接口定义：
      ```java 
          public interface Competitor<T extend Competitor<T>>{
            Outcome compete(T competitor);
          }
       ```
- 然后我们定义两个静态方法（使用静态方法是为了避免显式指定参数类型）。
  首先, match() 方法中调用了compete()方法，让两个Competitor 竞争，可以看到此处类型参数只需要是Competitor<T>。
  但在play() 方法中类型参数必须同时是Enum<T>（因为要放在Enums.random() 中使用）和Competitor<T> （因为 要传给match()）;
  
  ```java 
      public class RoShamBo{
          public static <T extend Competitor<T>> void match( T a , T b){
             System.out.println(a + ".vs" + b + ":" + a.compete(b));
          }
          public static <T extend Enum<T> & Competitor<T>> void play(Class<T> rsbClass, int size){
              for(int i = 0; i < size; i++){
                  match(Enums.random(rsbClass),Enums.random(rsbClass));
              }
          }
      }
      
  ```
                                      
- play()方法没有将类型参数T作为返回值，因此，似乎你应该在Class<T>中用通配符来取代主要的参数声明，然而通配符无法继承多个基类，因此我们必须使用上面的表达式。
  
- 使用方法：
    ```java
        
  public enum RoShamBo2 implements Competitor<RoShamBo2> {
  PAPER(DRAW, LOSE, WIN),
  SCISSORS(WIN, DRAW, LOSE),
  ROCK(LOSE, WIN, DRAW);
  private Outcome vPAPER, vSCISSORS, vROCK;
  RoShamBo2(Outcome paper,
    Outcome scissors, Outcome rock) {
    this.vPAPER = paper;
    this.vSCISSORS = scissors;
    this.vROCK = rock;
  }
  @Override public Outcome compete(RoShamBo2 it) {
    switch(it) {
      default:
      case PAPER: return vPAPER;
      case SCISSORS: return vSCISSORS;
      case ROCK: return vROCK;
    }
  }
  public static void main(String[] args) {
    RoShamBo.play(RoShamBo2.class, 20);
  }
}
/* Output:
ROCK vs. ROCK: DRAW
SCISSORS vs. ROCK: LOSE
SCISSORS vs. ROCK: LOSE
SCISSORS vs. ROCK: LOSE
PAPER vs. SCISSORS: LOSE
PAPER vs. PAPER: DRAW
PAPER vs. SCISSORS: LOSE
ROCK vs. SCISSORS: WIN
SCISSORS vs. SCISSORS: DRAW
ROCK vs. SCISSORS: WIN
SCISSORS vs. PAPER: WIN
SCISSORS vs. PAPER: WIN
ROCK vs. PAPER: LOSE
ROCK vs. SCISSORS: WIN
SCISSORS vs. ROCK: LOSE
PAPER vs. SCISSORS: LOSE
SCISSORS vs. PAPER: WIN
SCISSORS vs. PAPER: WIN
SCISSORS vs. PAPER: WIN
SCISSORS vs. PAPER: WIN
*/
  
    ```
